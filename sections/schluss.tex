\section{Schlussbemerkungen}
Der Diodentreiber konnte nicht in Betrieb genommen werden. Der Diodentreiber ist vorhanden und in die Steuerung eingebaut, konnte jedoch nicht fertig getestet werden. Die Ansteuerung soll analog erfolgen, was nicht funktioniert einwandfrei funktioniert hat. Am Ausgang konnte eine Spannung gemessen werden, der Strom zeigte jedoch lediglich $\approx$ 0.078A konstant und lies sich nicht steuern. Die Ursache für dieses Problem konnte noch nicht festgestellt werden. Es gibt einige Modi in der die Steuerung betrieben werden kann. Diese Modi werden eingestellt, indem auf der Platine Kontakte zusammen gelötet werden. Soll ein anderer Modus getestet werden, muss die bestehende Lötstelle aufgelöst werden und eine Andere zusammen gelötet werden. Zusätzlich besitzt der Diodentreiber keinerlei Indikator, wie eine LED, die den Status des Treibers anzeigt. Dies erschwert das Testen des Diodentreibers massiv. Der Laser kann somit nicht angesteuert werden. Es hätte mehr Zeit benötigt, den Treiber besser kennen zu verstehen.\\

Notaus konnte bisher nicht eingebaut werden --> Steuerung nicht sicher. Grund, der Notaus-Taster wurde nicht eingeplant.\\
% Der Diodentreiber liefert keine 30V, leider wurde davon ausgegangen, dass der Diodentreiber einen DC/DC Wandler \textit{on-board} hat, was so nicht der Fall ist. Es muss ein zweites Netzteil organisiert werden, das 30V liefert.\\a

Der Quellcode der Software funktioniert einwandfrei, trotzdem ist der Code unübersichtlich. Es wäre wünschenswert gewesen, wenn die Objektorientierung im gesamten hätte Code angewendet werden können. Die graphische Benutzeroberfläche beinhaltet einige Details wie Druckknöpfe, Rahmen und Texte die jeweils als ein Objekt hätten dargestellt werden können. Das \textit{Threading} verhinderte dies. Mit einer anderen Struktur müsste die trotzdem funktionieren. So wurde die Hauptfunktion des Hauptprogramms 771 Zeilen lang. Die oben genannten Angezeigten Komponenten werden in dieser Funktion alle einzeln erstellt, positioniert und mit Eigenschaften versehen, was die Anzahl Zeilen erklärt. Ersichtlich ist dies im Anhang im Kap. \ref{main_src}, Zeile 23 \textit{def \_\_init\_\_(self):}\footnote{Der Konstruktor \_\_init\_\_ wird benötigt, wenn ein neues Objekt einer Klasse erzeugt wird.} bis hin zur 791. Zeile ist die Initialisierungsfunktion oder \textit{Konstruktor} einer Klasse genannt \textit{\_\_init\_\_}. [18]\\

Für die Parallelisierung der Software wäre das asynchrone Programmieren vielleicht auch einfacher gewesen. Die Anwendung der Bibliothek ist wesentlich übersichtlicher und erzielt das selbe Ergebnis.\\

Der Aufbau des Quellcodes ist ab einem Punkt schwierig zu überblicken. Es war eine gute Entscheidung den Quellcode mit \textit{Git} einer Software zur Versionierung einzusetzen. 

Das Testen der einzelnen Komponenten hat einiges mehr Zeit in Anspruch genommen als Eingangs erwartet. Nahezu jedes Bauteil ist enorm vielfältig und kann in verschiedenen Modi verwendet werden. Dies eröffnete die Möglichkeit Ideen die im Vorfeld bestanden zu überdenken und die Steuerung anders aufzubauen. So wurde der Diodentreiber des Herstellers \textit{Optlaser} verwendet anstatt der von \textit{Mainman}. Die Ausgangsleistung von \textit{Optlaser} ist geeigneter, der von \textit{Maiman} mit einer sechsfach höheren Leistung zu hoch.\\
Für eine höhere Leistung des Rechners kann eine neuere Version des \textit{Raspberry PI}s verwendet werden. Diese ermöglichen das Anpassen der Leistungsparameter des Rechners. So können z.B. der Arbeitsspeicher erhöht werden.