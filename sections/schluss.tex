\section{Schlussbemerkungen}
Das Ansteuern des TEC-Kontrollers bzw. der TECs funktioniert einwandfrei. Die Temperaturen können sowohl gelesen, als auch gesteuert werden. Wie in Kap. \ref{chptr:hardware} angedeutet, hängt die Kühlleistung der TECs von der Kühlleistung der Wasserkühlung bzw. der Energiedissipation aus dem System ab. Die Wärme, die der Sockel der Pumpdiode bzw. der Sockel des Kristalls aufnehmen muss, muss aus dem System abgeführt werden. Die gewünschten Temperaturen können sonst ab einer gewissen Leistungshöhe der Pumpdiode bzw. des Kristalls nicht mehr gehalten werden. Die Temperaturen erhöhen sich somit kontinuierlich.
Damit wurde eine theoretische optische Leistung von etwa 5.6 W erreicht. Die endgültige benötigte Temperatur des Kühlwassers konnte somit nicht vollständig getestet werden, weil die Steuerung noch nicht an die Pumpdiode angeschlossen wurde.

Die Ansteuerung des Diodentreibers funktioniert einwandfrei. Für den Test wurde eine \textit{Dummy-Load} verwendet, in diesem Fall, ein Leistungswiderstand von 47 Ohm und eine Leistungsaufnahme von 100W angeschlossen. Das Einstellen des Stromflusses erfolgt über 15 Schritte von 0A-1.5A, in Schritten von jeweils 0.01A Schritten, jedoch mit den Einschränkungen der Sicherheitsparameter, erwähnt in Kapitel \ref{chptr:hardware} und \ref{chptr:software}.

Der Quellcode der Software funktioniert ebenfalls einwandfrei, ist teilweise jedoch ein wenig langsam.
Durch die Objektorientierung konnten beim Quell-Code über 400 Zeilen eingespart werden. Dies hat das Bearbeiten des Programms massiv erleichtert, weil die Übersicht des Programms besser wurde.

Das Steuerungskabel wurde noch nicht angeschlossen, weil mit der Steuerung immer noch Tests durchgeführt wurden. Das Kabel hätte das Testen massiv erschwert, weil dies die Verbindungen nach Aussen fixiert hätte. Die Ein- und Ausgänge der SPS mussten teilweise geändert werden, bei einem verlöteten Kabel würde dies hinderlich sein.

Die im Kapitel \ref{chptr:_einleitung} erwähnte Optimierung der Glasfaser, die bei genügend Zeit durchgeführt werden sollte, konnte nicht durchgeführt werden. Es stand nicht mehr genügend Zeit zur Verfügung.

Das Testen der einzelnen Komponenten hat einiges mehr Zeit in Anspruch genommen als Eingangs erwartet. Nahezu jedes Bauteil ist enorm vielfältig und kann in verschiedenen Modi verwendet werden. Dies eröffnete die Möglichkeit Ideen, die im Vorfeld bestanden zu überdenken und die Steuerung anders aufzubauen. So wurde der Diodentreiber des Herstellers \textit{Opt Lasers} verwendet, welcher geeigneter ist, als der von \textit{Maiman}. Die Ausgangsleistung von \textit{Opt Lasers} ist geringer, der Treiber von \textit{Maiman} mit einer sechsfach höheren Leistung zu hoch. [14]

Daneben war es nicht möglich, den Wunsch, die Temperaturen als Graphen auf der Digitalanzeige darzustellen. Dies vor allem aus dem Grund, dass das die Leistung der Steuerung beträchtlich beansprucht, welche durch die anderen Eigenschaften der Steuerung ausgeschöpft wird. Dazu waren die ergänzende Bibliotheken  von \textit{Matplotlib}, die für die Erstellung von Graphen in dieser Art Benutzeroberfläche angedacht ist, nicht vollständig in die Python-Umgebung eingebunden werden konnte. Daneben konnte nicht garantiert werden, dass dies mit \textit{Multithreading} einwandfrei funktioniert. 

Zusätzlich wurde beim Rechner anstatt ein Modell von Arduino, ein Raspberry PI verwendet. Auch dieser ist massiv komplexer als ein Mikroprozessor von Arduino. Die Version des Betriebssystem und die der Bibliotheken und Frameworks spielte nun eine signifikante Rolle. Mit dem komplexeren Rechner, konnte dafür ein vielfältigeres Programm erstellt werden. Das Potential der Steuerung erhöhte sich somit drastisch.

Ebenfalls konnte dem Wunsch nach einem Anmeldeverfahren mit verschiedenen Nutzer bzw. Nutzergruppen mit verschiedenen Berechtigungen nachgekommen werden. Die Steuerung kam mit dem jetzigen Umfang bereits an ihre Leistungsgrenze.

\subsection{Verbesserungsvorschläge}
Unter Umständen wäre für die Parallelisierung der Software das asynchrone Programmieren einfacher gewesen. Die Anwendung der Bibliothek ist wesentlich übersichtlicher und erzielt ein ähnliches Ergebnis.

Für eine höhere Leistung des Rechners könnte eine neuere Version des \textit{Raspberry PI}s verwendet werden, zum Beispiel der 4. oder 5. Generation. Diese ermöglichen das Anpassen der Leistungsparameter des Rechners, so kann zum Beispiel der Arbeitsspeicher drastisch erhöht werden und auch der Prozessor ist ein besserer, als die des Modell 3B+. [15]\\

Damit die gesamte Software auf dem Raspberry PI problemlos laufen kann, musste dieser angepasst werden. Es mussten weitere Bibliotheken für das Programm installiert werden und Einstellungen am Betriebssystem vorgenommen werden. Es müssen einige Dinge beachtet werden wie die Version der Bibliotheken und des Betriebssystems, was schnell unübersichtlich werden kann und schnell zu Fehlverhalten der Software führen kann. Um diese Probleme zu umgehen, kann man die gesamte Programmierumgebung in einen sogenannten \textit{Container} packen. Damit wird die Umgebung quasi zu einer gruppierten Einheit. So ist es möglich, ein System auf jedem anderen System mit den immer gleichen Voraussetzungen zu betreiben. Dies zeigt sich vor allem beim Bearbeiten der Software. Dieses \textit{Containern} kann man mit der Software \textit{Docker} realisieren. Für eine nächste Implementierung einer Steuerung im ähnlichen bis gleichen Rahmen, wie die vorliegende, wird diese Methode empfohlen.