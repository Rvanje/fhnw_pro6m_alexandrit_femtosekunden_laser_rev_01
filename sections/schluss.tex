\section{Schlussbemerkungen}
Das Ansteuern des TEC-Kontrollers bzw. der TECs funktioniert einwandfrei. Die Temperaturen können sowohl gelesen, als auch eingegeben werden. Das automatische finden der PID-Parameter, also das Regeln funktioniert jedoch noch nicht tadellos. In der Software des TEC-Kontrollers regelt der PID-Regler zwar auf die eingestellten Temperaturen, kann diese jedoch nicht effektiv annähern.\\
% Warum dies geschieht, ist noch unklar.
% Der Diodentreiber wurde in die Steuerung eingebaut, konnte jedoch nicht fertig getestet werden.
Auch das analoge Ansteuern des Diodentreibers funktioniert, jedoch nicht einwandfrei. Am Ausgang konnte eine Spannung und ein Strom gemessen und verändert werden. Für den Test, wurde eine \textit{Dummy-Load}  angeschlossen, in diesem Fall ein kleiner Laser. Das Einstellen des Stromflusses erfolgt über 15 Schritte von 0A-1.5A, in Schritten von jeweils 0.1A Schritten. Beim Einschalten der Steuerung leuchtete dieser und konnte auch in diesen Schritten gesteuert werden.  Beim Testen konnte immer nur bis zum zweiten Schritt gemessen werden, danach veränderte sich der Strom der Messung nicht mehr. Wurde die Spannung erhöht oder verringert, erhöhte bzw. verringerte sich der Stromfluss wieder. Dies entspricht zwar dem Strom-Spannung-Gesetz, konnte in der entsprechenden Zeit jedoch nicht behoben werden. Es hätte mehr Zeit benötigt, den Treiber besser zu verstehen.\\
Die Zeit reichte auch nicht aus, um einen Notaus-Taster und das Steuerungskabel zum Laseraufbau einzubauen. Der Notaus-Taster kam im Verlauf der Konstruktion der Steuerung hinzu und fand in der Ausarbeitungsphase keinen Platz mehr. Das Steuerungskabel konnte noch nicht angeschlossen werden, weil mit der Steuerung immer noch Tests durchgeführt wurden. Das Kabel hätte das Testen massiv erschwert, weil dies die Verbindungen nach Aussen fixiert hätte. Die Ein- und Ausgänge der SPS mussten teilweise geändert werden, bei einem verlöteten Kabel würde dies hinderlich sein.\\
Aus den oben genannten Gründen konnte die Steuerung nicht vollständig in Betrieb genommen werden. Die Sicherheit des Bedienenden und die der Komponenten wären nicht gewährleistet. Mit mehr Zeit könnten die Probleme wohl behoben werden. Dazu müssten jedoch mehr Test durchgeführt und den Notaus-Taster bzw. das Steuerungskabel installiert werden.\\

% Diese Modi werden eingestellt, indem auf der Platine Kontakte zusammen gelötet werden. Soll ein anderer Modus getestet werden, muss die bestehende Lötstelle aufgelöst werden und eine Andere zusammen gelötet werden. Zusätzlich besitzt der Diodentreiber keinerlei Indikator, wie eine LED, die den Status des Treibers anzeigt. Dies erschwert das Testen des Diodentreibers massiv. Der Laser kann somit nicht angesteuert werden. 

% Der Diodentreiber liefert keine 30V, leider wurde davon ausgegangen, dass der Diodentreiber einen DC/DC Wandler \textit{on-board} hat, was so nicht der Fall ist. Es muss ein zweites Netzteil organisiert werden, das 30V liefert.\\

Der Quellcode der Software funktioniert einwandfrei. Jedoch wäre es wünschenswert gewesen, wenn die Objektorientierung im gesamten Code hätte angewendet werden können, der Quellcode wäre so übersichtlicher geworden und hätte schneller erstellt werden können. Die graphische Benutzeroberfläche beinhaltet einige Details wie Druckknöpfe, Rahmen und Texte die jeweils als ein Objekt hätten erzeugt werden können. Diese hätten einwandfrei in Klassen beschrieben werden können, was so zwar erfolgreich getan und getestet wurde. Schlussendlich jedoch verhinderte dies das\textit{Multithreading}. In den mit der Objektorienterung erstellten Elemente, wurden die Temperatur- und Strom- bzw. Leistungswerte nicht mehr aktualisiert. Mit einer anderen Struktur oder einer Anpassung des jetzigen Aufbaus, müsste dies trotzdem möglich sein. So wurde die Hauptfunktion des Hauptprogramms 771 Zeilen lang. Die oben genannten Angezeigten Komponenten werden in dieser Funktion alle einzeln erstellt, positioniert und mit Eigenschaften versehen, was die erhöhte Anzahl Zeilen erklärt. Ersichtlich ist dies im Anhang im Kap. \ref{main_src}, Zeile 23 bis hin zur 791. Zeile ist der Konstruktor \textit{def \_\_init\_\_(self):} zu sehen. Trotz der einwandfreien Funktion des Quellcodes, könnte dieser ein wenig übersichtlicher sein. [18]\\

Daneben wäre für die Parallelisierung der Software, das asynchrone Programmieren vielleicht einfacher gewesen. Die Anwendung der Bibliothek ist wesentlich übersichtlicher und erzielt das selbe Ergebnis.\\

% Der Aufbau des Quellcodes ist ab einem Punkt schwierig zu überblicken. Es war eine gute Entscheidung den Quellcode mit \textit{Git} einer Software zur Versionierung einzusetzen. 

Das Testen der einzelnen Komponenten hat einiges mehr Zeit in Anspruch genommen als Eingangs erwartet. Nahezu jedes Bauteil ist enorm vielfältig und kann in verschiedenen Modi verwendet werden. Dies eröffnete die Möglichkeit Ideen die im Vorfeld bestanden, zu überdenken und die Steuerung anders aufzubauen. So wurde der Diodentreiber des Herstellers \textit{Optlaser} verwendet, anstatt der von \textit{Mainman}. Die Ausgangsleistung von \textit{Optlaser} ist geeigneter, der von \textit{Maiman} mit einer sechsfach höheren Leistung zu hoch.\\
Zusätzlich wurde beim Rechner anstatt ein Modell von Arduino, ein Raspberry PI verwendet. Auch dieser ist einiges komplexer als ein Arduino Mikroprozessor. Die Version des Betriebssystem und die der Bibliotheken und Frameworks spielte nun eine Rolle. Mit dem komplexeren Rechner, konnte jedoch ein vielfältigeres Programm erstellt werden. Das Potential der Steuerung erhöhte sich somit drastisch.
Für eine höhere Leistung des Rechners kann eine neuere Version des \textit{Raspberry PI}s verwendet werden. Diese ermöglichen das Anpassen der Leistungsparameter des Rechners, so kann zum Beispiel der Arbeitsspeicher drastisch erhöht werden.\\

Dass die Steuerung nicht abgeschlossen werden konnte, hatte zu Folge, dass die Optimierung der Glasfaser nicht angegangen werden konnte.