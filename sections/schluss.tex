\section{Schlussbemerkungen}
Das Ansteuern des TEC-Kontrollers bzw. der TECs funktioniert einwandfrei. Die Temperaturen können sowohl gelesen, als auch eingegeben werden. Das automatische finden der PID-Parameter, also das Regeln funktioniert jedoch noch nicht tadellos. In der Software des TEC-Kontrollers regelt der PID-Regler zwar auf die eingestellten Temperaturen, kann diese jedoch nicht effektiv annähern. Um die Parameter zu finden, sollte die Steuerung auf dem Zielsystem angewendet werden. Auf diese Weise könnten die PID-Parameter besser gefunden werden.\\

Die Ansteuerung des Diodentreibers funktioniert einwandfrei. Für den Test wurde eine \textit{Dummy-Load} angebracht,  Für den Test, wurde eine \textit{Dummy-Load} angeschlossen, in diesem Fall ein Leistungswiderstand von 47 Ohm und eine Leistungsaufnahme von 100W. Das Einstellen des Stromflusses erfolgt über 15 Schritte von 0A-1.5A, in Schritten von jeweils 0.1A Schritten, jedoch mit Eingeschränkt der Sicherheitsparameter, erwähnt in Kapitel \ref{chptr:hardware} und \ref{chptr:software}.

%Beim Einschalten der Steuerung leuchtete dieser und konnte auch in diesen Schritten gesteuert werden.  Beim Testen konnte immer nur bis zum zweiten Schritt gemessen werden, danach veränderte sich der Strom der Messung nicht mehr. Wurde die Spannung erhöht oder verringert, erhöhte bzw. verringerte sich der Stromfluss wieder. Dies entspricht zwar dem Strom-Spannung-Gesetz, konnte in der entsprechenden Zeit jedoch nicht behoben werden. Es hätte mehr Zeit benötigt, den Treiber besser zu verstehen.\\

Die Zeit reichte nicht aus, um einen Notaus-Taster und das Steuerungskabel zum Laseraufbau einzubauen. Der Notaus-Taster kam im Verlauf der Konstruktion der Steuerung hinzu und fand in der Ausarbeitungsphase keinen Platz mehr. Das Steuerungskabel konnte noch nicht angeschlossen werden, weil mit der Steuerung immer noch Tests durchgeführt wurden. Das Kabel hätte das Testen massiv erschwert, weil dies die Verbindungen nach Aussen fixiert hätte. Die Ein- und Ausgänge der SPS mussten teilweise geändert werden, bei einem verlöteten Kabel würde dies hinderlich sein.\\
%  Aus den oben genannten Gründen konnte die Steuerung nicht vollständig in Betrieb genommen werden. Die Sicherheit des Bedienenden und die der Komponenten wären nicht gewährleistet. Mit mehr Zeit könnten die Probleme wohl behoben werden. Dazu müssten jedoch mehr Test durchgeführt und den Notaus-Taster bzw. das Steuerungskabel installiert werden.\\

% Diese Modi werden eingestellt, indem auf der Platine Kontakte zusammen gelötet werden. Soll ein anderer Modus getestet werden, muss die bestehende Lötstelle aufgelöst werden und eine Andere zusammen gelötet werden. Zusätzlich besitzt der Diodentreiber keinerlei Indikator, wie eine LED, die den Status des Treibers anzeigt. Dies erschwert das Testen des Diodentreibers massiv. Der Laser kann somit nicht angesteuert werden. 

Der Quellcode der Software funktioniert einwandfrei. Durch die Objektorientierung konnten beim Quell-Code über 200 Zeilen eingespart werden. Dies hat das Bearbeiten des Programms massiv erleichtert.

% Der Quellcode der Software funktioniert einwandfrei. Jedoch wäre es wünschenswert gewesen, wenn die Objektorientierung im gesamten Code hätte angewendet werden können, der Quellcode wäre so übersichtlicher geworden und hätte schneller erstellt werden können. Die graphische Benutzeroberfläche beinhaltet einige Details wie Druckknöpfe, Rahmen und Texte die jeweils als ein Objekt hätten erzeugt werden können. Diese hätten einwandfrei in Klassen beschrieben werden können, was so zwar erfolgreich getan und getestet wurde. Schlussendlich jedoch verhinderte dies das \textit{Multithreading}. In den mit der Objektorienterung erstellten Elemente, wurden die Temperatur- und Strom- bzw. Leistungswerte nicht mehr aktualisiert. Mit einer anderen Struktur oder einer Anpassung des jetzigen Aufbaus, müsste dies trotzdem möglich sein. So wurde die Hauptfunktion des Hauptprogramms 771 Zeilen lang. Die oben genannten Angezeigten Komponenten werden in dieser Funktion alle einzeln erstellt, positioniert und mit Eigenschaften versehen, was die erhöhte Anzahl Zeilen erklärt. Ersichtlich ist dies im Anhang im Kap. \ref{main_src}, Zeile 23 bis hin zur 791. Zeile ist der Konstruktor \textit{def \_\_init\_\_(self):} zu sehen. Trotz der einwandfreien Funktion des Quellcodes, könnte dieser ein wenig übersichtlicher sein. [12]\\

Daneben war es nicht möglich, die Temperaturen als Graphen auf der Digitalanzeige darzustellen. Dies vor allem aus dem Grund, dass die ergänzende Bibliotheken \textit{Matplotlib}, die für die Erstellung von Graphen angedacht ist, nicht vollständig in die Python-Umgebung eingebunden werden konnte. Dazu konnte nicht garantiert werden, dass dies mit \textit{Multithreading} einwandfrei funktioniert.

 Unter Umständen wäre für die Parallelisierung der Software, das asynchrone Programmieren vielleicht einfacher gewesen. Die Anwendung der Bibliothek ist wesentlich übersichtlicher und erzielt das selbe Ergebnis.\\

Das Testen der einzelnen Komponenten hat einiges mehr Zeit in Anspruch genommen als Eingangs erwartet. Nahezu jedes Bauteil ist enorm vielfältig und kann in verschiedenen Modi verwendet werden. Dies eröffnete die Möglichkeit Ideen die im Vorfeld bestanden, zu überdenken und die Steuerung anders aufzubauen. So wurde der Diodentreiber des Herstellers \textit{Opt Lasers} verwendet welcher geeigneter ist, als der von \textit{Maiman}. Die Ausgangsleistung von \textit{Opt Lasers} ist geringer, der von \textit{Maiman} mit einer sechsfach höheren Leistung zu hoch. [14]\\
Zusätzlich wurde beim Rechner anstatt ein Modell von Arduino, ein Raspberry PI verwendet. Auch dieser ist einiges komplexer als ein Mikroprozessor von Arduino. Die Version des Betriebssystem und die der Bibliotheken und Frameworks spielte nun eine siginfikante Rolle. Mit dem komplexeren Rechner, konnte jedoch ein vielfältigeres Programm erstellt werden. Das Potential der Steuerung erhöhte sich somit drastisch.
Für eine höhere Leistung des Rechners kann eine neuere Version des \textit{Raspberry PI}s verwendet werden zum Beispiel der 4. oder 5. Generation. Diese ermöglichen das Anpassen der Leistungsparameter des Rechners, so kann zum Beispiel der Arbeitsspeicher drastisch erhöht werden und auch der Prozessor ist ein besserer, als die des Modell 3B+. [15]\\

Damit die gesamte Software auf dem Raspberry PI problemlos laufen kann, wie bereits erwähnt angepasst werden. Es mussten weitere Bibliotheken für das Programm installiert werden und Einstellungen am Betriebssystem vorgenommen werden. Es müssen einige Dinge beachtet werden wie die Version der Bibliotheken und des Betriebssystems was schnell unübersichtlich werden kann und schnell zu Fehlverhalten der Software führen kann. Um diese Probleme zu umgehen, kann man die gesamte Programmierumgebung in einen sogenanntet \textit{Container} packen. Damit wird die Umgebung quasi zu einer gruppierten Einheit. So ist es möglich, ein System auf jedem anderen System mit den immer gleichen Voraussetzungen zu betreiben. Dies zeigt sich vor allem beim Bearbeiten der Software. Dieses \textit{Containern} kann man mit einer Software namens \textit{Docker} umgehen. Für eine nächste Implementierung einer Steuerung im ähnlichen bis gleichen Rahmen, wie die vorliegende, wird diese Methode empfohlen.